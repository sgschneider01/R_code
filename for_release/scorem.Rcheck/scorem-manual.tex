\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8,latin1]{inputenc}
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `scorem'}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Statistical Consolidation of Redundant Expression Measures}
\item[Version]\AsIs{1.0}
\item[Date]\AsIs{2011-06-13}
\item[Author]\AsIs{Stephanie G. Schneider}
\item[Maintainer]\AsIs{}\email{stauber@bu.edu}\AsIs{}
\item[Description]\AsIs{Analyzes and consolidates concordant redundant expression
measures (probe sets) for microarrays.}
\item[License]\AsIs{LGPL}
\item[Depends]\AsIs{R (>= 2.7.0), Biobase, affy, limma, graph, genefilter}
\item[Suggests]\AsIs{MASS, org.Hs.eg.db, org.Mm.eg.db}
\item[LazyLoad]\AsIs{yes}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{scorem-package}{SCOREM: Statistical Consolidation of Redundant Expression Measures}{scorem.Rdash.package}
\aliasA{scorem}{scorem-package}{scorem}
\keyword{package}{scorem-package}
%
\begin{Description}\relax
SCOREM is a tool for the consolidation of Affymetrix probe set expression values into gene- or transcript-specific expression values. SCOREM is intended to be used with the affy, gcrma, and limma packages, to produce an MArrayLM object with consolidated coefficients and p values, and a TestResults object of classified results.
\end{Description}
%
\begin{Details}\relax

\Tabular{ll}{
Package: & scorem\\{}
Type: & Package\\{}
Version: & 1.0\\{}
Date: & 2011-06-30\\{}
License: & LGPL\\{}
LazyLoad: & yes\\{}
}
Given an \code{ExpressionSet} object of normalized expression data (such as output by \code{\LinkA{gcrma}{gcrma}}) and an \code{MArrayLM} object output by \code{\LinkA{eBayes}{eBayes}}, \code{\LinkA{makeGroups}{makeGroups}} determines which probe sets are behaving concordantly and can be consolidated, \code{\LinkA{consolidateGroups}{consolidateGroups}} consolidates the values in the \code{MArrayLM} object, and \code{\LinkA{decideTests}{decideTests}} produces the \code{TestResults} object. \code{\LinkA{findDiscords}{findDiscords}} can be performed on a \code{TestResults} object to locate discordant probe sets or groups for the same gene, i.e., groups that are indicate differential expression in opposite directions under the same test conditions (time point, treatment, etc.)
\end{Details}
%
\begin{Author}\relax
Stephanie G. Schneider
\end{Author}
%
\begin{References}\relax
SCOREM: Statistical Consolidation of Redundant Expression Measures.  NAR 2011.
\end{References}
%
\begin{SeeAlso}\relax
\code{\LinkA{affy}{affy}}
\code{\LinkA{gcrma}{gcrma}}
\code{\LinkA{limma}{limma}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{consolidateGroups}{Consolidation of Concordant Probe Set Groups}{consolidateGroups}
\keyword{\textbackslash{}textasciitilde{}kwd1}{consolidateGroups}
\keyword{\textbackslash{}textasciitilde{}kwd2}{consolidateGroups}
%
\begin{Description}\relax
Combines coefficients and p-values of an \code{MArrayLM} object using a data frame of concordant groups output by \code{makeGroups}.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
consolidateGroups(object, new.ids)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{MArrayLM} object output from \code{\LinkA{eBayes}{eBayes}}, containing the coefficients and p-values to be consolidated.

\item[\code{new.ids}] 
A data frame of probe set ids and new consolidated ids, generated by \code{\LinkA{makeGroups}{makeGroups}}.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
An \code{MArrayLM} object.
\end{Value}
%
\begin{Author}\relax
Stephanie G. Schneider
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{makeGroups}{makeGroups}},\code{\LinkA{eBayes}{eBayes}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (object, new.ids)
{
  m <- object$coefficients  
  m <- subset(m,rownames(m) %in% new.ids$probe_id)  
  new.ids <- subset(new.ids, new.ids$probe_id %in% rownames(m))
  m <- data.frame(m[as.character(new.ids$probe_id),])
  m <- apply(m,2,function(x) tapply(x,as.character(new.ids$new.gene_id),mean))

  p <- object$p.value
  p <- subset(p,rownames(p) %in% new.ids$probe_id)  
  p <- data.frame(p[as.character(new.ids$probe_id),])
  p <- apply(p,2,function(x) tapply(x,as.character(new.ids$new.gene_id), fisher.p))

  object$coefficients <- m
  object$p.value <- p
  return(object)
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{decideTests}{Multiple Testing Across Genes and Contrasts}{decideTests}
\keyword{\textbackslash{}textasciitilde{}kwd1}{decideTests}
\keyword{\textbackslash{}textasciitilde{}kwd2}{decideTests}
%
\begin{Description}\relax
A modified version of the limma package method.  Classify a series of related t-statistics as up, down or not significant. A number of different multiple testing schemes are offered which adjust for multiple testing down the genes as well as across contrasts for each gene.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
decideTests(object, method = "sliding", adjust.method = "BH", p.value = 0.05, lfc = 0, tau = sqrt(2))
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{MArrayLM} object output from \code{\LinkA{consolidateGroups}{consolidateGroups}} from which the t-statistics may be extracted.

\item[\code{method}] 
character string specify how probes and contrasts are to be combined in the multiple testing strategy. Choices are "separate", "global", "hierarchical", "nestedF", "sliding", or any partial string.

\item[\code{adjust.method}] 
character string specifying p-value adjustment method. Possible values are "none", "BH", "fdr" (equivalent to "BH"), "BY" and "holm". See p.adjust for details.

\item[\code{p.value}] 
numeric value between 0 and 1 giving the desired size of the test

\item[\code{lfc}] 
minimum log2-fold-change required

\item[\code{tau}] 
numeric value between 1 and 2 setting the steepness of the sigmoid function used by the "sliding" method.  As tau approaches 1, the curve approaches the hard cutoff produced by method "separate".

\end{ldescription}
\end{Arguments}
%
\begin{Value}
An object of class \code{TestResults}. This is essentially a numeric matrix with elements -1, 0 or 1 depending on whether each t-statistic is classified as significantly negative, not significant or significantly positive respectively.
\end{Value}
%
\begin{Author}\relax
Stephanie G. Schneider
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{limma}{limma}},\code{\LinkA{consolidateGroups}{consolidateGroups}}

\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (object, method = "sliding", adjust.method = "BH", 
    p.value = 0.05, lfc = 0, tau=sqrt(2)) 
{
    if (!is(object, "MArrayLM")) 
        stop("Need MArrayLM object")
    if (is.null(object$p.value)) 
        object <- eBayes(object)
    method <- match.arg(method, c("separate", "global", "sliding",
        "hierarchical", "nestedF"))
    adjust.method <- match.arg(adjust.method, c("none", "bonferroni", 
        "holm", "BH", "fdr", "BY"))
    if (adjust.method == "fdr") 
        adjust.method <- "BH"
    switch(method, separate = {
        p <- as.matrix(object$p.value)
        for (j in 1:ncol(p)) {
            o <- !is.na(p[, j])
            p[o, j] <- p.adjust(p[o, j], method = adjust.method)
        }
        s <- sign(as.matrix(object$coefficients))
        results <- new("TestResults", s * (p < p.value))
        if (lfc > 0) 
          results@.Data <- results@.Data * (abs(object$coefficients) > lfc)
    }, global = {
        p <- as.matrix(object$p.value)
        o <- !is.na(p)
        p[o] <- p.adjust(p[o], method = adjust.method)
        s <- sign(as.matrix(object$coefficients))
        results <- new("TestResults", s * (p < p.value))
        if (lfc > 0) 
          results@.Data <- results@.Data * (abs(object$coefficients) > lfc)
    }, sliding = {
        p <- as.matrix(object$p.value)
        for (j in 1:ncol(p)) {
            o <- !is.na(p[, j])
            p[o, j] <- p.adjust(p[o, j], method = adjust.method)
        }
        m <- as.matrix(object$coefficients)
        m.a <- abs(m)
        beta <- log(4)/(tau-1)
        alf <- p.value/(1+exp(beta*(tau-m.a)))  
          # if (p.value=.05 & m.a=1) then alf=.01 regardless of tau
          #   tau defines the midpoint, ie where p=.5*p.value
        s <- sign(m)
        results <- new("TestResults", s * (p < alf))
    }, hierarchical = {
        stop("Can't handle hierarchical method yet")
    }, nestedF = {
        stop("Can't handle nestedF method yet")
    })
    results
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{findDiscords}{Detection of Redundant Groups Differentially Expressed in Opposite Directions}{findDiscords}
\keyword{\textbackslash{}textasciitilde{}kwd1}{findDiscords}
\keyword{\textbackslash{}textasciitilde{}kwd2}{findDiscords}
%
\begin{Description}\relax
Given an \code{TestResults} object output by \code{\LinkA{decideTests}{decideTests}}, returns a list of matrices for all genes with discordant groups, i.e., groups that are differentially expressed in opposite directions.  
\end{Description}
%
\begin{Usage}
\begin{verbatim}
findDiscords(object)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{object}] 
\code{TestResults} object output by \code{decideTests}.

\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
Identifies genes with with discordant groups, i.e., groups that are differentially expressed in opposite directions, and for each extracts a subset of the \code{TestResults} matrix containing the discordant values.
\end{Details}
%
\begin{Value}
A list containing subset of the \code{TestResults} matrix where discordant expression patterns are observed.
\end{Value}
%
\begin{Author}\relax
Stephanie G. Schneider
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{decideTests}{decideTests}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function(object) { 
  egs <- neweg2old(rownames(object))
  object <- subset(object, egs %in% get.duped(egs))
  if (nrow(object)==0) return ()

  egs <- neweg2old(rownames(object))  # reset after subsetting
  x <- tapply(rownames(object),egs,
              function(y) subset(object,rownames(object) %in% y),
              simplify=F)
  # creates a list of arrays, one for each egid

  if (ncol(object)>1) { 
    u <- sapply(x,function(y) {
      t(subset(t(y),apply(y,2,function(z) {
         length(unique(sign(subset(z,z!=0)))) > 1
      })))
    })
  } else {
     # when there is only one contrast
     u <- sapply(x,function(y) {
        length(unique(sign(subset(y[,1],y[,1]!=0)))) > 1
     })
  }
  u <- subset(u, sapply(u,function(v)ncol(v)>0))
  return (u)
  }
\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{makeGroups}{Make Groups of Concordant Probe Sets for Consolidation}{makeGroups}
\keyword{\textbackslash{}textasciitilde{}kwd1}{makeGroups}
\keyword{\textbackslash{}textasciitilde{}kwd2}{makeGroups}
%
\begin{Description}\relax
Given an \code{ExpressionSet} object of normalized data, determines the concordance of redundant probe sets (representing the same gene), producing a data frame of old probe set ids with new ids indicating which can be consolidated.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
makeGroups(eset, ann.table = NULL, filtered = TRUE, alpha = 0.01)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{eset}] 
\code{\LinkA{ExpressionSet}{ExpressionSet}} object output by \code{\LinkA{gcrma}{gcrma}} or other normalization algorithm.

\item[\code{ann.table}] 
data frame output from makeAnnTable.

\item[\code{filtered}] 
logical value indicating whether or not the data has already been filtered. If FALSE, \code{genefilter} is performed to remove probe sets with extremely low variance.

\item[\code{alpha}] 
numerical value between 0 and 1, indicating the level of significance required for correlation to be considered significant.

\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame object mapping probe set ids to group ids.
\end{Value}
%
\begin{Author}\relax
Stephanie G. Schneider
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{gcrma}{gcrma}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
##---- Should be DIRECTLY executable !! ----
##-- ==>  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (eset, ann.table=NULL, filtered=TRUE, alpha=.01) {
cat("Please be patient, this make take a few minutes.\n")

  if (!filtered)  eset <- filterGenes(eset)
  if (is.null(ann.table))  ann.table <- makeAnnTable(annotation(eset))
 
  exprs.eset <- exprs(eset)
  nc <- ncol(exprs.eset)
  r.crit <- getRcrit(alpha,nc)
  w.crit <- (1+r.crit)/2

  ann.table <- subset(ann.table, ann.table$probe_id %in% rownames(exprs.eset))
  multiples <- subset(ann.table,ann.table$Freq>1)
  new.ps.num <- by(multiples,multiples$gene_id,function(ss) {
    eset.rows <- subset(exprs.eset, rownames(exprs.eset) %in% ss$probe_id)
    if (nrow(eset.rows)>1) {
      mat <- cor(t(eset.rows),method="spearman")
      w   <- mean(mat,na.rm=TRUE) 
      if (w >= w.crit) {
        ss$ps.num <- paste(ss$ps.num,collapse='_')
      } else {
        sg <- getSubGraphs(mat,alpha,nc,w.crit)  # returns names not indices
        for (s in sg) {
          if (!is.numeric(s))  s <- sort(match(s,ss$probe_id))
          ss$ps.num[s] <- paste(ss$ps.num[s],collapse="_")
        }
      } 
    }
    ss$ps.num
  })
  multiples$ps.num <- unlist(new.ps.num,use.names=F)
  singles <- subset(ann.table,ann.table$Freq==1)
  multiples <- rbind(multiples,singles)
  new.eg.ids <- paste(multiples$gene_id,multiples$ps.num,sep='.')
  new.eg.ids <- paste(new.eg.ids,multiples$Freq,sep='.')  
  new.ids <- data.frame(probe_id=multiples$probe_id, new.gene_id=new.eg.ids)
  new.ids
  }
\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
